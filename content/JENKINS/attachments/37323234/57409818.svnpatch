Index: .settings/org.eclipse.jdt.core.prefs
===================================================================
--- .settings/org.eclipse.jdt.core.prefs	(revision 0)
+++ .settings/org.eclipse.jdt.core.prefs	(revision 0)
@@ -0,0 +1,264 @@
+#Wed Jun 22 14:19:18 CEST 2011
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
+org.eclipse.jdt.core.compiler.source=1.5
+org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_assignment=0
+org.eclipse.jdt.core.formatter.alignment_for_binary_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_compact_if=16
+org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
+org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
+org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
+org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
+org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_after_package=1
+org.eclipse.jdt.core.formatter.blank_lines_before_field=0
+org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=0
+org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
+org.eclipse.jdt.core.formatter.blank_lines_before_method=1
+org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk=1
+org.eclipse.jdt.core.formatter.blank_lines_before_package=0
+org.eclipse.jdt.core.formatter.blank_lines_between_import_groups=1
+org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=1
+org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_array_initializer=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
+org.eclipse.jdt.core.formatter.comment.format_block_comments=true
+org.eclipse.jdt.core.formatter.comment.format_header=false
+org.eclipse.jdt.core.formatter.comment.format_html=true
+org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
+org.eclipse.jdt.core.formatter.comment.format_line_comments=true
+org.eclipse.jdt.core.formatter.comment.format_source_code=true
+org.eclipse.jdt.core.formatter.comment.indent_parameter_description=true
+org.eclipse.jdt.core.formatter.comment.indent_root_tags=true
+org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=insert
+org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=insert
+org.eclipse.jdt.core.formatter.comment.line_length=80
+org.eclipse.jdt.core.formatter.compact_else_if=true
+org.eclipse.jdt.core.formatter.continuation_indentation=2
+org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=2
+org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=true
+org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_empty_lines=false
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_block=true
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=false
+org.eclipse.jdt.core.formatter.indentation.size=4
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_member=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw=insert
+org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.join_lines_in_comments=true
+org.eclipse.jdt.core.formatter.join_wrapped_lines=true
+org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.lineSplit=80
+org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=false
+org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=false
+org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
+org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
+org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
+org.eclipse.jdt.core.formatter.tabulation.char=mixed
+org.eclipse.jdt.core.formatter.tabulation.size=8
+org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=false
+org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
Index: .settings/org.eclipse.jdt.ui.prefs
===================================================================
--- .settings/org.eclipse.jdt.ui.prefs	(revision 0)
+++ .settings/org.eclipse.jdt.ui.prefs	(revision 0)
@@ -0,0 +1,4 @@
+#Wed Jun 22 14:19:17 CEST 2011
+eclipse.preferences.version=1
+formatter_profile=org.eclipse.jdt.ui.default.sun_profile
+formatter_settings_version=11
Index: .settings/org.maven.ide.eclipse.prefs
===================================================================
--- .settings/org.maven.ide.eclipse.prefs	(revision 0)
+++ .settings/org.maven.ide.eclipse.prefs	(revision 0)
@@ -0,0 +1,8 @@
+#Wed Jun 22 09:39:55 CEST 2011
+activeProfiles=
+eclipse.preferences.version=1
+fullBuildGoals=process-test-resources
+resolveWorkspaceProjects=true
+resourceFilterGoals=process-resources resources\:testResources
+skipCompilerPlugin=true
+version=1
Index: src/main/java/com/mtvi/plateng/subversion/SVNPublisher.java
===================================================================
--- src/main/java/com/mtvi/plateng/subversion/SVNPublisher.java	(revision 39591)
+++ src/main/java/com/mtvi/plateng/subversion/SVNPublisher.java	(working copy)
@@ -23,219 +23,238 @@
 import org.kohsuke.stapler.DataBoundConstructor;
 import org.kohsuke.stapler.StaplerRequest;
 
-
 /**
- * 	The hudson plugin wrapper is based off of (and on occasion copied verbatim from) the twitter plugin
- * by justinedelson and cactusman.
+ * The hudson plugin wrapper is based off of (and on occasion copied verbatim
+ * from) the twitter plugin by justinedelson and cactusman.
  * 
  * @author bsmith
  * 
  */
 public class SVNPublisher extends Notifier {
 
-        @Extension
-        public static final DescriptorImpl DESCRIPTOR = new DescriptorImpl();
-        private static final Logger LOGGER = Logger.getLogger(SVNPublisher.class.getName());
+    @Extension
+    public static final DescriptorImpl DESCRIPTOR = new DescriptorImpl();
+    private static final Logger LOGGER = Logger.getLogger(SVNPublisher.class
+	    .getName());
 
-        private String svnUrl;
-        private String pomPath;
-        private String target;
-        private ArrayList<ImportItem> items;
-        private String user;
-        private String password;
-        private String majorPath;
-        private String minorPath;
-        private String patchPath;
-        private String workspace = "NA";
-     
-     /**
+    private String svnUrl;
+    private String pomPath;
+    private String target;
+    private ArrayList<ImportItem> items;
+    private String user;
+    private String password;
+    private String majorPath;
+    private String minorPath;
+    private String patchPath;
+    private String workspace = "NA";
+
+    /**
      * {@stapler-constructor}
      */
     @DataBoundConstructor
-    public SVNPublisher(String svnUrl, String pomPath, String target, ArrayList<ImportItem> items, String user, String password, String majorPath, String minorPath, String patchPath){
-        this.svnUrl = svnUrl;
-        this.pomPath = pomPath;
-        this.target = target;
-        this.items = items;
-        this.user = user;
-        this.password = password;
-        this.majorPath = majorPath;
-        this.minorPath = minorPath;
-        this.patchPath = patchPath;
+    public SVNPublisher(final String svnUrl, final String pomPath,
+	    final String target, final ArrayList<ImportItem> items,
+	    final String user, final String password, final String majorPath,
+	    final String minorPath, final String patchPath) {
+	this.svnUrl = svnUrl;
+	this.pomPath = pomPath;
+	this.target = target;
+	this.items = items;
+	this.user = user;
+	this.password = password;
+	this.majorPath = majorPath;
+	this.minorPath = minorPath;
+	this.patchPath = patchPath;
     }
 
     public String getSvnUrl() {
-        return svnUrl;
+	return svnUrl;
     }
-    
+
     public String getPomPath() {
-        return pomPath;
+	return pomPath;
     }
-    
+
     public String getTarget() {
-        return target;
+	return target;
     }
-    
+
     public ArrayList<ImportItem> getItems() {
-        return items;
+	return items;
     }
-    
-    public void setItems(ArrayList <ImportItem> items){
-    	this.items = items;
+
+    public void setItems(final ArrayList<ImportItem> items) {
+	this.items = items;
     }
-    
+
     public String getUser() {
-        return user;
+	return user;
     }
-    
+
     public String getPassword() {
-        return password;
+	return password;
     }
-    
+
     public String getMajorPath() {
-        return majorPath;
+	return majorPath;
     }
-    
+
     public String getMinorPath() {
-        return minorPath;
+	return minorPath;
     }
-    
+
     public String getPatchPath() {
-        return patchPath;
+	return patchPath;
     }
 
-    public boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) {
-    	return _perform(build, launcher, listener);
-    }
+    @Override
+    public boolean perform(final AbstractBuild<?, ?> build,
+	    final Launcher launcher, final BuildListener listener) {
 
-    protected <P extends AbstractProject<P, B>, B extends AbstractBuild<P, B>> boolean _perform(B build,
-            Launcher launcher, BuildListener listener) {
-        if (build.getResult() == Result.SUCCESS){
-        	try{
-        		workspace = build.getWorkspace().toURI().getPath();
-        		listener.getLogger().println("workspace: " + workspace);
-        	}catch (Exception e){
-        		
-        	}
-        
-        	listener.getLogger().println("Attempting to import to SVN: " + svnUrl);
-            try {
-                DESCRIPTOR.svnImport(svnUrl, target, items, user, password, pomPath, majorPath, minorPath, patchPath, workspace, listener.getLogger());
-            } catch (Exception e) {
-                LOGGER.log(Level.SEVERE, "Unable to import to svn.", e);
-            }
-        }
-        return true;
+	if (build.getResult() == Result.SUCCESS) {
+	    try {
+		workspace = build.getWorkspace().toURI().getPath();
+		listener.getLogger().println("workspace: " + workspace);
+	    } catch (Exception e) {
 
+	    }
+
+	    listener.getLogger().println(
+		    "Attempting to import to SVN: " + svnUrl);
+	    try {
+		DESCRIPTOR.svnImport(svnUrl, target, items, user, password,
+			pomPath, majorPath, minorPath, patchPath, workspace,
+			listener.getLogger());
+	    } catch (Exception e) {
+		LOGGER.log(Level.SEVERE, "Unable to import to svn.", e);
+	    }
+	}
+	return true;
     }
 
     public BuildStepMonitor getRequiredMonitorService() {
-        return BuildStepMonitor.BUILD;
+	return BuildStepMonitor.BUILD;
     }
 
-        public static final class DescriptorImpl extends BuildStepDescriptor<Publisher> {
-            private static final Logger LOGGER = Logger.getLogger(DescriptorImpl.class.getName());
+    public static final class DescriptorImpl extends
+	    BuildStepDescriptor<Publisher> {
+	private static final Logger LOGGER = Logger
+		.getLogger(DescriptorImpl.class.getName());
 
-            private static final List<String> VALUES_REPLACED_WITH_NULL = Arrays.asList("",
-                    "(Default)", "(System Default)");
-            
-            public String svnUrl;
-            public String pomPath;
-            public String target;
-            public ArrayList <ImportItem> items;
-            public String user;
-            public String password;
-            public String majorPath;
-            public String minorPath;
-            public String patchPath;
-                        
-            protected DescriptorImpl() {
-                super(SVNPublisher.class);
-                load();
-            }
-           
-            
-        /**
-         * Clean up the formData object by removing blanks and (Default) values.
-         * 
-         * @param formData
-         *            the incoming form data
-         * @return a new cleaned JSONObject object
-         */
-        protected static JSONObject cleanJSON(JSONObject formData) {
-            JSONObject cleaned = new JSONObject();
-            for (Object key : formData.keySet()) {
-                Object o = formData.get(key);
-                if (o instanceof String) {
-                    if (!VALUES_REPLACED_WITH_NULL.contains((String)o)) {
-                        cleaned.put(key, o);
-                    }
-                } else {
-                    cleaned.put(key, o);
-                }
-            }
-            return cleaned;
-        }
-        
-        @Override
-        public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {
+	private static final List<String> VALUES_REPLACED_WITH_NULL = Arrays
+		.asList("", "(Default)", "(System Default)");
 
-            req.bindParameters(this, "svnpublish.");
-            save();
-            return super.configure(req, formData);
-        }
-        
-        @Override
-        public String getDisplayName() {
-            return "Publish to Subversion repository";
-        }
+	public String svnUrl;
+	public String pomPath;
+	public String target;
+	public ArrayList<ImportItem> items;
+	public String user;
+	public String password;
+	public String majorPath;
+	public String minorPath;
+	public String patchPath;
 
-        public String getSvnUrl() {
-            return svnUrl;
-        }
-        
-        public String getTarget() {
-            return target;
-        }
-        
-        public String getPomPath() {
-            return pomPath;
-        }
-        
-        
-        public List<ImportItem> getItems(SVNPublisher instance) {
-            if (instance == null) {
-                return new ArrayList<ImportItem> ();
-            }
-            return instance.getItems(); 
-        }
-        public String getUser() {
-            return user;
-        }
+	protected DescriptorImpl() {
+	    super(SVNPublisher.class);
+	    load();
+	}
 
-        public String getPassword() {
-            return password;
-        }
+	/**
+	 * Clean up the formData object by removing blanks and (Default) values.
+	 * 
+	 * @param formData
+	 *            the incoming form data
+	 * @return a new cleaned JSONObject object
+	 */
+	protected static JSONObject cleanJSON(final JSONObject formData) {
+	    JSONObject cleaned = new JSONObject();
+	    for (Object keyObj : formData.keySet()) {
+		String key = String.valueOf(keyObj);
+		Object o = formData.get(key);
+		if (o instanceof String) {
+		    if (!VALUES_REPLACED_WITH_NULL.contains(o)) {
+			cleaned.put(key, o);
+		    }
+		} else {
+		    cleaned.put(key, o);
+		}
+	    }
+	    return cleaned;
+	}
 
-        @Override
-        public boolean isApplicable(Class<? extends AbstractProject> jobType) {
-            return true;
-        }
-        
-        @Override
-        public Publisher newInstance(StaplerRequest req, JSONObject formData) throws FormException {
-            JSONObject cleanedFormData = cleanJSON(formData);
-            SVNPublisher instance = req.bindJSON(SVNPublisher.class, cleanedFormData);
-            ArrayList<ImportItem> itemsList = new ArrayList<ImportItem>(req.bindJSONToList(ImportItem.class, cleanedFormData.get("itm")));
-            instance.setItems(itemsList);
+	@Override
+	public boolean configure(final StaplerRequest req,
+		final JSONObject formData) throws FormException {
 
-            return instance;
-        }
+	    req.bindParameters(this, "svnpublish.");
+	    save();
+	    return super.configure(req, formData);
+	}
 
-        public void svnImport(String svnUrl, String target, ArrayList<ImportItem> items, String user, String password, String pomPath,  String majorPath, String minorPath, String patchPath, String workspace, PrintStream stream) throws Exception {
-                        
-             SVNForceImport.forceImport(svnUrl, user, password, target,  items, pomPath, majorPath, minorPath, patchPath, workspace, stream);
-	
-        }
+	@Override
+	public String getDisplayName() {
+	    return "Publish to Subversion repository";
+	}
+
+	public String getSvnUrl() {
+	    return svnUrl;
+	}
+
+	public String getTarget() {
+	    return target;
+	}
+
+	public String getPomPath() {
+	    return pomPath;
+	}
+
+	public List<ImportItem> getItems(final SVNPublisher instance) {
+	    if (instance == null) {
+		return new ArrayList<ImportItem>();
+	    }
+	    return instance.getItems();
+	}
+
+	public String getUser() {
+	    return user;
+	}
+
+	public String getPassword() {
+	    return password;
+	}
+
+	@Override
+	public boolean isApplicable(
+		final Class<? extends AbstractProject> jobType) {
+	    return true;
+	}
+
+	@Override
+	public Publisher newInstance(final StaplerRequest req,
+		final JSONObject formData) throws FormException {
+	    JSONObject cleanedFormData = cleanJSON(formData);
+	    SVNPublisher instance = req.bindJSON(SVNPublisher.class,
+		    cleanedFormData);
+	    ArrayList<ImportItem> itemsList = new ArrayList<ImportItem>(req
+		    .bindJSONToList(ImportItem.class, cleanedFormData
+			    .get("itm")));
+	    instance.setItems(itemsList);
+
+	    return instance;
+	}
+
+	public void svnImport(final String svnUrl, final String target,
+		final ArrayList<ImportItem> items, final String user,
+		final String password, final String pomPath,
+		final String majorPath, final String minorPath,
+		final String patchPath, final String workspace,
+		final PrintStream stream) throws Exception {
+
+	    SVNForceImport
+		    .forceImport(svnUrl, user, password, target, items,
+			    pomPath, majorPath, minorPath, patchPath,
+			    workspace, stream);
+
+	}
     }
 }
Index: src/main/java/com/mtvi/plateng/subversion/SVNForceImport.java
===================================================================
--- src/main/java/com/mtvi/plateng/subversion/SVNForceImport.java	(revision 39591)
+++ src/main/java/com/mtvi/plateng/subversion/SVNForceImport.java	(working copy)
@@ -1,9 +1,13 @@
-
 package com.mtvi.plateng.subversion;
 
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
 import java.io.PrintStream;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.logging.Logger;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -20,384 +24,661 @@
 import org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;
 import org.tmatesoft.svn.core.io.SVNRepository;
 import org.tmatesoft.svn.core.io.SVNRepositoryFactory;
+import org.tmatesoft.svn.core.wc.SVNClientManager;
 import org.tmatesoft.svn.core.wc.SVNCommitClient;
+import org.tmatesoft.svn.core.wc.SVNCommitPacket;
+import org.tmatesoft.svn.core.wc.SVNInfo;
+import org.tmatesoft.svn.core.wc.SVNRevision;
+import org.tmatesoft.svn.core.wc.SVNUpdateClient;
+import org.tmatesoft.svn.core.wc.SVNWCClient;
 import org.tmatesoft.svn.core.wc.SVNWCUtil;
 
+import com.google.common.io.Files;
 
-
 /**
- * SVNForceImport can be used to import a maven project into an svn repository. It has the ability to import numerous
- * different files/folders based on matching a regular expression pattern. Each matched item can be renamed and placed
- * in differing folders. 
+ * SVNForceImport can be used to import a maven project into an svn repository.
+ * It has the ability to import numerous different files/folders based on
+ * matching a regular expression pattern. Each matched item can be renamed and
+ * placed in differing folders.
  * 
- * SVNForceImport can also read a projects pom file and extract Major Minor and Patch version numbers.
+ * SVNForceImport can also read a projects pom file and extract Major Minor and
+ * Patch version numbers.
  * 
  * @author bsmith
  * @version 0.1
  */
 public class SVNForceImport {
-	private static final Logger LOGGER = Logger.getLogger(SVNForceImport.class.getName());
+    private static final Logger LOGGER = Logger.getLogger(SVNForceImport.class
+	    .getName());
 
-	/**
-	 * Main method, used by hudson until a plugin wrapper can be written.
-	 * 
-	 * @param args Arguments consist of switches and values as follows:<p>
-	 * <ul>
-	 *             
-	 * <li> -r <code>repository_url</code><br>  
-	 *      REQUIRED: The url of the repository to be used, should include the path to the project.<br><br>
-	 *             
-	 * <li> -t <code>target_path</code><br> 	
-	 *      REQUIRED: The path to the local target directory.<br><br>
-	 *             
-	 * <li> -pom <code>pom.xml_path</code><br>	
-	 *     	REQUIRED: The path to the project's pom file.<br><br>
-	 *             
-	 * <li> -i <code>file_pattern</code> <code>remote_path</code> <code>remote_name</code><br>	
-	 *      REQUIRED, MULTIPLE: The item(s) (file/folder) to be imported.<br>
-	 *      All arguments may use _MAJOR_,_MINOR_, and _PATCH_ to replace with pom values.<br>
-	 *      <ul>
-	 *      <li><code>file_pattern</code>: Only items fitting this pattern will be imported.<br>
-	 *      <li><code>remote_path</code>:	Path from remote project to desired location, ends in "/". _ROOT_ places item in project root.<br>
-	 *      <li><code>remote_name</code>:	Final name for imported item, multiple items matching the same pattern are prepended with numbers.<br>
-	 *      </ul><br><br>
-	 *      
-	 *             
-	 * <li> -u <code>svn_username</code><br>		
-	 *     	OPTIONAL: svn username<br><br>
-	 *             
-	 * <li> -p <code>svn_password</code><br>		
-	 *     	OPTIONAL: svn password<br>
-	 * </ul>
-	 */
-	public static void main(String[] args) {
-		
-		ArrayList <ImportItem> importItems = new ArrayList <ImportItem>();
-		String svnURL = "";
-		String pomPath = "";
-		String target = "";
-		String user = "";
-		String password = "";
+    /**
+     * Main method, used by hudson until a plugin wrapper can be written.
+     * 
+     * @param args
+     *            Arguments consist of switches and values as follows:
+     *            <p>
+     *            <ul>
+     * 
+     *            <li>-r <code>repository_url</code><br>
+     *            REQUIRED: The url of the repository to be used, should include
+     *            the path to the project.<br>
+     *            <br>
+     * 
+     *            <li>-t <code>target_path</code><br>
+     *            REQUIRED: The path to the local target directory.<br>
+     *            <br>
+     * 
+     *            <li>-pom <code>pom.xml_path</code><br>
+     *            REQUIRED: The path to the project's pom file.<br>
+     *            <br>
+     * 
+     *            <li>-i <code>file_pattern</code> <code>remote_path</code>
+     *            <code>remote_name</code><br>
+     *            REQUIRED, MULTIPLE: The item(s) (file/folder) to be imported.<br>
+     *            All arguments may use _MAJOR_,_MINOR_, and _PATCH_ to replace
+     *            with pom values.<br>
+     *            <ul>
+     *            <li><code>file_pattern</code>: Only items fitting this pattern
+     *            will be imported.<br>
+     *            <li><code>remote_path</code>: Path from remote project to
+     *            desired location, ends in "/". _ROOT_ places item in project
+     *            root.<br>
+     *            <li><code>remote_name</code>: Final name for imported item,
+     *            multiple items matching the same pattern are prepended with
+     *            numbers.<br>
+     *            </ul>
+     *            <br>
+     *            <br>
+     * 
+     * 
+     *            <li>-u <code>svn_username</code><br>
+     *            OPTIONAL: svn username<br>
+     *            <br>
+     * 
+     *            <li>-p <code>svn_password</code><br>
+     *            OPTIONAL: svn password<br>
+     *            </ul>
+     */
+    public static void main(final String[] args) {
 
-		// read through given options
-		// I thought about creating an enumeration for these, but I'd rather just write the wrapper.
-		try{
-			for (int i = 0; i < args.length;){
+	ArrayList<ImportItem> importItems = new ArrayList<ImportItem>();
+	String svnURL = "";
+	String pomPath = "";
+	String target = "";
+	String user = "";
+	String password = "";
 
-				if(args[i].equalsIgnoreCase("-r")){
-					// set repositoryURL
-					svnURL = args[i+1];
-					i+= 2;
+	// read through given options
+	// I thought about creating an enumeration for these, but I'd rather
+	// just write the wrapper.
+	try {
+	    for (int i = 0; i < args.length;) {
 
-				}else if(args[i].equalsIgnoreCase("-i")){
-					// add item
-					importItems.add(new ImportItem(args[i+1], args[i+2], args[i+3]));
-					i+= 4;
-					
-				}else if(args[i].equalsIgnoreCase("-u")){
-					// set username
-					user = args[i+1];
-					i+=2;
+		if (args[i].equalsIgnoreCase("-r")) {
+		    // set repositoryURL
+		    svnURL = args[i + 1];
+		    i += 2;
 
-				}else if(args[i].equalsIgnoreCase("-p")){
-					// set password
-					password = args[i+1];
-					i+=2;
+		} else if (args[i].equalsIgnoreCase("-i")) {
+		    // add item
+		    importItems.add(new ImportItem(args[i + 1], args[i + 2],
+			    args[i + 3]));
+		    i += 4;
 
-				}else if(args[i].equalsIgnoreCase("-pom")){
-					// set pomPath
-					pomPath = args[i+1];
-					i+=2;
-				}
-				else if(args[i].equalsIgnoreCase("-t")){
-					// set pomPath
-					target = args[i+1];
-					i+=2;
-				}
-			}
-			if (svnURL.length()==0){
-				System.err.println("SVNForceImport Error: Missing repository URL\n");
-			}
-		} catch(Exception e){
-			System.err.println("SVNForceImport Error: Error while parsing options\n");
+		} else if (args[i].equalsIgnoreCase("-u")) {
+		    // set username
+		    user = args[i + 1];
+		    i += 2;
+
+		} else if (args[i].equalsIgnoreCase("-p")) {
+		    // set password
+		    password = args[i + 1];
+		    i += 2;
+
+		} else if (args[i].equalsIgnoreCase("-pom")) {
+		    // set pomPath
+		    pomPath = args[i + 1];
+		    i += 2;
+		} else if (args[i].equalsIgnoreCase("-t")) {
+		    // set pomPath
+		    target = args[i + 1];
+		    i += 2;
 		}
-		forceImport(svnURL, user, password, target, importItems, pomPath ,null, null, null, null, null);
-		
+	    }
+	    if (svnURL.length() == 0) {
+		System.err
+			.println("SVNForceImport Error: Missing repository URL\n");
+	    }
+	} catch (Exception e) {
+	    System.err
+		    .println("SVNForceImport Error: Error while parsing options\n");
 	}
-	
-	/**
-	 * The core SVNForceImport method, used to import files into a repository.
-	 * 
-	 * @param svnURL		The url of the repository including path to project root.
-	 * @param user			The username to use for repository access.
-	 * @param password		The password to use for repository access.
-	 * @param target		The path to the local target directory, where items are found.
-	 * @param items			The ImportItems to be imported.
-	 * @param pomPath		The path to the project's pom.xml file.
-	 * @param majorPath		The xml path to the major version in the pom file.
-	 * @param minorPath		The xml path to the minor version in the pom file.
-	 * @param patchPath		The xml path to the patch version in the pom file.
-	 */
-	public static void forceImport(String svnURL, String user, String password, String target, ArrayList<ImportItem> items, String pomPath, String majorPath, String minorPath, String patchPath, String workspace, PrintStream stream){
-		
-		if (null != workspace){
-			
-			workspace = workspace.substring(0,workspace.length()-1);
-			target = target.replaceAll("_WORKSPACE_", workspace);
-			stream.println("SVN Publisher: target: " + target);
-			
-			if (null != pomPath){
-				pomPath = pomPath.replaceAll("_WORKSPACE_", workspace);
-				stream.println("SVN Publisher: pomPath: " + pomPath);
-			}
+	forceImport(svnURL, user, password, target, importItems, pomPath, null,
+		null, null, null, null);
+
+    }
+
+    /**
+     * The core SVNForceImport method, used to import files into a repository.
+     * 
+     * @param svnURL
+     *            The url of the repository including path to project root.
+     * @param user
+     *            The username to use for repository access.
+     * @param password
+     *            The password to use for repository access.
+     * @param target
+     *            The path to the local target directory, where items are found.
+     * @param items
+     *            The ImportItems to be imported.
+     * @param pomPath
+     *            The path to the project's pom.xml file.
+     * @param majorPath
+     *            The xml path to the major version in the pom file.
+     * @param minorPath
+     *            The xml path to the minor version in the pom file.
+     * @param patchPath
+     *            The xml path to the patch version in the pom file.
+     */
+    @SuppressWarnings("deprecation")
+    public static void forceImport(final String svnURL, final String user,
+	    final String password, String target,
+	    final ArrayList<ImportItem> items, String pomPath,
+	    final String majorPath, final String minorPath,
+	    final String patchPath, String workspace, final PrintStream stream) {
+
+	if (null != workspace) {
+
+	    workspace = workspace.substring(0, workspace.length() - 1);
+	    target = target.replaceAll("_WORKSPACE_", workspace);
+	    target = target.replaceAll("$WORKSPACE", workspace);
+	    stream.println("SVN Publisher: target: " + target);
+
+	    if (null != pomPath) {
+		pomPath = pomPath.replaceAll("_WORKSPACE_", workspace);
+		pomPath = pomPath.replaceAll("$WORKSPACE", workspace);
+		stream.println("SVN Publisher: pomPath: " + pomPath);
+	    }
+	}
+
+	// target directory is required
+	File targetDir = new File(target);
+
+	if (!targetDir.canRead()) {
+	    LOGGER
+		    .severe("SVNForceImport Error: target Directory not accessable: "
+			    + target);
+	    if (null != stream) {
+		stream
+			.println("SVN Publisher: Error: target Directory not accessable: "
+				+ target);
+	    }
+	}
+
+	// pom is not required, but without it MAJOR/MINOR/PATCH variables won't
+	// be available
+
+	SimplePOMParser spp = new SimplePOMParser();
+	if (null != pomPath) {
+
+	    File pom = new File(pomPath);
+	    if (!pom.canRead()) {
+
+		LOGGER.severe("SVNForceImport Error: pom File not accessable: "
+			+ pomPath);
+		if (null != stream) {
+		    stream
+			    .println("SVN Publisher: Error: pom File not accessable: "
+				    + pomPath);
 		}
-		
-		// target directory is required
-		File targetDir = new File(target);
-		if (!targetDir.canRead()) {
-			LOGGER.severe("SVNForceImport Error: target Directory not accessable: " + target);
-			if (null != stream){
-				stream.println("SVN Publisher: Error: target Directory not accessable: " + target);
-			}
+	    }
+	    spp.setMajorPath(majorPath);
+	    spp.setMinorPath(minorPath);
+	    spp.setPatchPath(patchPath);
+	    spp.parse(pom);
+	}
+
+	DAVRepositoryFactory.setup();
+
+	SVNRepository repository = null;
+	ISVNAuthenticationManager authManager = SVNWCUtil
+		.createDefaultAuthenticationManager();
+
+	// create the repo and authManager
+	try {
+	    setupProtocols();
+	    repository = SVNRepositoryFactory.create(SVNURL
+		    .parseURIEncoded(svnURL));
+	    if (null != user) {
+		authManager = SVNWCUtil.createDefaultAuthenticationManager(
+			user, password);
+	    }
+	    repository.setAuthenticationManager(authManager);
+
+	    SVNClientManager ourClientManager = SVNClientManager.newInstance(
+		    null, repository.getAuthenticationManager());
+
+	    // create the commit client that will do the work
+	    SVNCommitClient commitClient = ourClientManager.getCommitClient();
+
+	    SVNUpdateClient updateClient = ourClientManager.getUpdateClient();
+
+	    SVNWCClient wcClient = ourClientManager.getWCClient();
+
+	    // import each item
+	    String finalName;
+	    String finalPath;
+	    String finalPattern;
+	    for (ImportItem item : items) {
+		// if the pom and major/minor/patch paths have been included
+		// attempt to do some simple replacement
+		boolean nullName = false;
+
+		finalName = "";
+		finalPath = "";
+		finalPattern = "";
+
+		if ((null == item.getName()) || (item.getName().length() < 1)) {
+		    LOGGER.info("null Name");
+		    nullName = true;
+		} else {
+
+		    finalName = variableReplace(spp, item.getName());
 		}
-		
-		// pom is not required, but without it MAJOR/MINOR/PATCH variables won't be available
 
-		SimplePOMParser spp = new SimplePOMParser();
-		if (null != pomPath){
-			
-			File pom  = new File(pomPath);
-			if (!pom.canRead()){
-				
-				LOGGER.severe("SVNForceImport Error: pom File not accessable: " + pomPath);
-				if (null != stream){
-					stream.println("SVN Publisher: Error: pom File not accessable: " + pomPath);
-				}
-			}
-			spp.setMajorPath(majorPath);
-			spp.setMinorPath(minorPath);
-			spp.setPatchPath(patchPath);
-			spp.parse(pom);
+		finalPattern = variableReplace(spp, item.getPattern());
+		finalPath = variableReplace(spp, item.getPath());
+
+		// Added BZ Checkout
+
+		File svnTempDir = new File(target + File.separator + "svntemp"
+			+ File.separator
+			+ finalPath.replace("/", File.separator));
+
+		if (svnTempDir.exists()) {
+		    stream.println("SVN Publisher: update: " + svnURL + "/"
+			    + finalPath + " to " + svnTempDir);
+		    long revision = updateClient.doUpdate(svnTempDir,
+			    SVNRevision.HEAD, SVNDepth.INFINITY, true, true);
+		    stream.println("SVN Publisher: revision: " + revision);
+		} else {
+		    stream.println("SVN Publisher: Checkout: " + svnURL + "/"
+			    + finalPath + " to " + svnTempDir);
+		    long revision = updateClient.doCheckout(SVNURL
+			    .parseURIEncoded(svnURL + "/" + finalPath),
+			    svnTempDir, SVNRevision.HEAD, SVNRevision.HEAD,
+			    SVNDepth.INFINITY, true);
+		    stream.println("SVN Publisher: revision: " + revision);
+
 		}
-		
-		SVNRepository repository = null;
-		ISVNAuthenticationManager authManager = SVNWCUtil.createDefaultAuthenticationManager();
+		// look for files
 
-		// create the repo and authManager
-		try {
-			setupProtocols();
-			repository = SVNRepositoryFactory.create(SVNURL.parseURIEncoded(svnURL));
-			if (null != user){
-				authManager = SVNWCUtil.createDefaultAuthenticationManager(user, password);
+		ArrayList<String> changed = new ArrayList<String>();
+
+		ArrayList<File> files = matchFiles(finalPattern, targetDir);
+		String prefix = "";
+		for (int i = 0; i < files.size(); i++) {
+
+		    ensurePath(repository, commitClient, svnURL, finalPath);
+
+		    File file = files.get(i);
+		    if (!file.canRead()) {
+			LOGGER
+				.severe("SVNForceImport Error: File/Directory not accessable: "
+					+ file.getAbsolutePath());
+			if (null != stream) {
+			    stream
+				    .println("SVN Publisher: Error: File/Directory not accessable: "
+					    + file.getAbsolutePath());
 			}
-			repository.setAuthenticationManager(authManager);
+		    }
 
-		
-			// create the commit client that will do the work
-			SVNCommitClient commitClient = new SVNCommitClient(authManager, null);
-			
-			// import each item
-			String finalName;
-			String finalPath;
-			String finalPattern;
-			for (ImportItem item: items){
-				// if the pom and major/minor/patch paths have been included attempt to do some simple replacement
-				boolean nullName = false;
-				
-				finalName = "";
-				finalPath= "";
-				finalPattern = "";
-				
-				if ((null == item.getName()) || (item.getName().length() < 1)){
-					LOGGER.info("null Name");
-					nullName = true;
-				}else{
-					
-					finalName = variableReplace(spp, item.getName());
-				}
-				
-				finalPattern = variableReplace(spp, item.getPattern());
-				finalPath = variableReplace(spp, item.getPath());
-				
-				ArrayList<File> files = matchFiles(finalPattern, targetDir);
-				String prefix = "";
-				for (int i = 0; i < files.size(); i++){
-					
-					ensurePath(repository, commitClient, svnURL, finalPath);
-					
-					if (!files.get(i).canRead()) {
-						LOGGER.severe("SVNForceImport Error: File/Directory not accessable: " + files.get(i).getAbsolutePath());
-						if (null != stream){
-							stream.println("SVN Publisher: Error: File/Directory not accessable: " + files.get(i).getAbsolutePath());
-						}
-					}
-					
-					if (nullName){
-						finalName = files.get(i).getName();
-					}
-					SVNNodeKind nodeKind = repository.checkPath(finalPath + prefix + finalName, -1);
-					if (nodeKind == SVNNodeKind.NONE){
-						insertItem(commitClient, svnURL + "/" + finalPath, files.get(i), prefix + finalName);
-						if (null != stream){
-							stream.println("SVN Publisher: Importing Item: " + prefix + finalName);
-						}
-					} else {
-						deleteItem(commitClient, svnURL + "/" + finalPath + prefix + finalName);
-						if (null != stream){
-							stream.println("SVN Publisher: Deleting Remote Item: " + prefix + finalName);
-						}
-						insertItem(commitClient, svnURL + "/" + finalPath, files.get(i), prefix + finalName);
-						if (null != stream){
-							stream.println("SVN Publisher: Importing Item: " + prefix + finalName);
-						}
-					}
-					
-					prefix = Integer.toString(i + 1);
-					
-				}
-			
+		    if (nullName) {
+			finalName = file.getName();
+		    }
+		    SVNNodeKind nodeKind = repository.checkPath(finalPath
+			    + prefix + finalName, -1);
+		    if (nodeKind == SVNNodeKind.NONE) {
+			insertItem(commitClient, svnURL + "/" + finalPath,
+				file, prefix + finalName);
+			if (null != stream) {
+			    stream.println("SVN Publisher: Importing Item: "
+				    + prefix + finalName);
 			}
-		}catch (SVNException svne) {
+		    } else {
 
-			LOGGER.severe("*SVNForceImport Error: " + svne.getMessage());
+			stream.println("SVN Publisher: Comparing Item: "
+				+ prefix + finalName);
+			File snvFile = new File(svnTempDir.getAbsolutePath()
+				+ File.separator + finalName);
+			if (!fileContentsEquals(file, snvFile)) {
+			    if (copyFile(file, snvFile)) {
+				stream
+					.println("SVN Publisher: File Copied to: "
+						+ snvFile);
+
+				changed.add(finalName);
+
+				SVNInfo doInfo = wcClient.doInfo(snvFile,
+					SVNRevision.HEAD);
+
+				stream.println("SVN Publisher: Info: "
+					+ doInfo.getPropTime()
+					+ " getCommittedDate: "
+					+ doInfo.getCommittedDate()
+					+ " getRevision: "
+					+ doInfo.getRevision() + " getAuthor: "
+					+ doInfo.getAuthor());
+			    }
+			}
+			// File[] paths = new File[] { file };
+			// deleteItem(commitClient, svnURL + "/" + finalPath
+			// + prefix + finalName);
+			// if (null != stream) {
+			// stream
+			// .println("SVN Publisher: Deleting Remote Item: "
+			// + prefix + finalName);
+			// }
+			// insertItem(commitClient, svnURL + "/" + finalPath,
+			// files.get(i), prefix + finalName);
+			// if (null != stream) {
+			// stream.println("SVN Publisher: Importing Item: "
+			// + prefix + finalName);
+			// }
+		    }
+
+		    // prefix = Integer.toString(i + 1);
+
 		}
+		// Temp Path
+
+		File[] svnTempPath = new File[] { svnTempDir };
+
+		SVNInfo doInfo = wcClient.doInfo(svnTempDir, SVNRevision.HEAD);
+
+		stream.println("SVN Publisher: Info: " + doInfo.getPropTime()
+			+ " getCommittedDate: " + doInfo.getCommittedDate()
+			+ " getRevision: " + doInfo.getRevision()
+			+ " getAuthor: " + doInfo.getAuthor());
+
+		SVNCommitPacket ci = commitClient.doCollectCommitItems(
+			svnTempPath, false, true, SVNDepth.INFINITY, null);
+		stream.println("SVN Publisher: do Commit: " + ci.toString());
+
+		SVNCommitInfo doCommit = commitClient.doCommit(ci, false,
+			"Jenkins");
+
+		stream.println("SVN Publisher: Commit result: "
+			+ doCommit.toString());
+
+	    }
+	} catch (SVNException svne) {
+	    stream
+		    .println("SVN Publisher: Commit result: "
+			    + svne.getMessage());
+	    LOGGER.severe("*SVNForceImport Error: " + svne.getMessage());
 	}
-	
-	/**
-	 * Insert a given file/folder into the given repository location with a given name
-	 * 
-	 * @param client			The SVNCommitClient to be used to preform the commit action.
-	 * @param fullURL			The full URL pointing to where the importItem will be placed.
-	 * @param importItem		The file or folder to be imported in the repository.
-	 * @param name				The file/folder name to be used in the repository.
-	 * @return 					The results of the commit action.
-	 * @throws SVNException
-	 */
-	private static SVNCommitInfo insertItem(SVNCommitClient client, String fullURL, File importItem, String name)
-	throws SVNException {
-		String logMessage = "SVNForceImport importing: " + importItem.getAbsolutePath();
-		return client.doImport(
-				importItem, 							// File/Directory to be imported
-				SVNURL.parseURIEncoded(fullURL + name), // location within svn 
-				logMessage, 							// svn comment
-				new SVNProperties(), 					// svn properties
-				true, 									// use global ignores
-				false, 									// ignore unknown node types
-				SVNDepth.INFINITY); 					// fully recursive
+    }
 
+    private static boolean copyFile(final File file, final File snvFile) {
+
+	try {
+	    Files.copy(file, snvFile);
+	} catch (FileNotFoundException e) {
+	    return false;
+	} catch (IOException e) {
+	    return false;
 	}
+	return true;
+    }
 
-	/**
-	 * Delete a given file/folder from the repository.
-	 * 
-	 * @param client			The SVNCommitClient to be used to preform the commit action.
-	 * @param fullURL			The full URL pointing to the item to be deleted.
-	 * @return					The result of the commit action.
-	 * @throws SVNException
-	 */
-	private static SVNCommitInfo deleteItem(SVNCommitClient client, String fullURL)
-	throws SVNException {
+    /**
+     * Insert a given file/folder into the given repository location with a
+     * given name
+     * 
+     * @param client
+     *            The SVNCommitClient to be used to preform the commit action.
+     * @param fullURL
+     *            The full URL pointing to where the importItem will be placed.
+     * @param importItem
+     *            The file or folder to be imported in the repository.
+     * @param name
+     *            The file/folder name to be used in the repository.
+     * @return The results of the commit action.
+     * @throws SVNException
+     */
+    private static SVNCommitInfo insertItem(final SVNCommitClient client,
+	    final String fullURL, final File importItem, final String name)
+	    throws SVNException {
+	String logMessage = "SVNForceImport importing: "
+		+ importItem.getAbsolutePath();
+	return client.doImport(importItem, // File/Directory to be imported
+		SVNURL.parseURIEncoded(fullURL + name), // location within svn
+		logMessage, // svn comment
+		new SVNProperties(), // svn properties
+		true, // use global ignores
+		false, // ignore unknown node types
+		SVNDepth.INFINITY); // fully recursive
 
-		String logMessage = "SVNForceImport removing: " + fullURL;
-		SVNURL[] urls = {SVNURL.parseURIEncoded(fullURL)};
-		return client.doDelete(urls, logMessage);
+    }
 
+    /**
+     * Delete a given file/folder from the repository.
+     * 
+     * @param client
+     *            The SVNCommitClient to be used to preform the commit action.
+     * @param fullURL
+     *            The full URL pointing to the item to be deleted.
+     * @return The result of the commit action.
+     * @throws SVNException
+     */
+    private static SVNCommitInfo deleteItem(final SVNCommitClient client,
+	    final String fullURL) throws SVNException {
+
+	String logMessage = "SVNForceImport removing: " + fullURL;
+	SVNURL[] urls = { SVNURL.parseURIEncoded(fullURL) };
+	return client.doDelete(urls, logMessage);
+
+    }
+
+    /**
+     * Create a given directory in the repository.
+     * 
+     * @param client
+     *            The SVNCommitClient to be used to preform the mkdir action.
+     * @param fullPath
+     *            The full URL pointing to where the Directory should be created
+     *            (including the directory to be created).
+     * @return The result of the commit action.
+     * @throws SVNException
+     */
+    private static SVNCommitInfo createDir(final SVNCommitClient client,
+	    final String fullPath) throws SVNException {
+
+	String logMessage = "SVNForceImport creating Directory : " + fullPath;
+	SVNURL[] urls = { SVNURL.parseURIEncoded(fullPath) };
+	return client.doMkDir(urls, logMessage);
+
+    }
+
+    /**
+     * Set up the different repository protocol factories so that
+     * http,https,svn,and file protocols can all be used.
+     */
+    private static void setupProtocols() {
+
+	// http and https
+	DAVRepositoryFactory.setup();
+	// svn
+	SVNRepositoryFactoryImpl.setup();
+	// file
+	FSRepositoryFactory.setup();
+    }
+
+    /**
+     * Search through a given directory and return an ArrayList of any
+     * files/folders who's names match the given pattern.
+     * 
+     * @param patternString
+     *            The regular expression pattern to use in matching applicable
+     *            file/folder names
+     * @param parent
+     *            The folder to search for matches in.
+     * @return All files/folders matching the given pattern.
+     */
+    private static ArrayList<File> matchFiles(final String patternString,
+	    final File parent) {
+	Pattern pattern = Pattern.compile(patternString);
+	Matcher matcher;
+	ArrayList<File> files = new ArrayList<File>();
+	for (File file : parent.listFiles()) {
+	    matcher = pattern.matcher(file.getName());
+	    if (matcher.matches()) {
+		files.add(file);
+	    }
 	}
+	return files;
 
-	/**
-	 * Create a given directory in the repository.
-	 * 
-	 * @param client			The SVNCommitClient to be used to preform the mkdir action.
-	 * @param fullPath			The full URL pointing to where the Directory should be created (including the directory to be created).
-	 * @return					The result of the commit action.
-	 * @throws SVNException
-	 */
-	private static SVNCommitInfo createDir(SVNCommitClient client, String fullPath)
-	throws SVNException {
+    }
 
-		String logMessage = "SVNForceImport creating Directory : " + fullPath;
-		SVNURL[] urls = {SVNURL.parseURIEncoded(fullPath)};
-		return client.doMkDir(urls, logMessage);
+    /**
+     * Replace variable names with their values.
+     * 
+     * @param spp
+     *            The SimplePOMParser containing the required variables.
+     * @param value
+     *            The String to be filtered.
+     * @return The new String with variable names replaced with values
+     */
+    private static String variableReplace(final SimplePOMParser spp,
+	    String value) {
 
+	value = value.replace("_ROOT_", "");
+	value = value.replace("_MAJOR_", Integer.toString(spp.getMajor()));
+	value = value.replace("_MINOR_", Integer.toString(spp.getMinor()));
+	value = value.replace("_PATCH_", Integer.toString(spp.getPatch()));
+	return value;
+
+    }
+
+    /**
+     * Validate the the required path exists in the project on the repository.
+     * If it doesn't then create it.
+     * 
+     * @param repository
+     *            The repository to be checked.
+     * @param commitClient
+     *            The SVNCommitClient to be used to preform any commit actions.
+     * @param svnURL
+     *            The URL of the project in the repository.
+     * @param path
+     *            The path within the project to be checked/created.
+     */
+    private static void ensurePath(final SVNRepository repository,
+	    final SVNCommitClient commitClient, final String svnURL,
+	    final String path) {
+	String[] dirs = path.split("/");
+	String constructedPath = "";
+
+	if (dirs.length > 0) {
+
+	    for (String dir : dirs) {
+		try {
+		    SVNNodeKind nodeKind = repository.checkPath(constructedPath
+			    + dir, -1);
+		    if (nodeKind == SVNNodeKind.NONE) {
+			createDir(commitClient, svnURL + "/" + constructedPath
+				+ dir);
+		    }
+		    constructedPath += dir + "/";
+
+		} catch (SVNException svne) {
+		    System.err.println("SVNForceImport Error: "
+			    + svne.getMessage());
+		}
+	    }
 	}
+    }
 
-	/**
-	 * Set up the different repository protocol factories so that http,https,svn,and file protocols can all be used.
-	 */
-	private static void setupProtocols() {
+    private final static int BUFFSIZE = 1024;
+    private static byte buff1[] = new byte[BUFFSIZE];
+    private static byte buff2[] = new byte[BUFFSIZE];
 
-		// http and https
-		DAVRepositoryFactory.setup();
-		// svn
-		SVNRepositoryFactoryImpl.setup();
-		// file
-		FSRepositoryFactory.setup();
+    public static boolean inputStreamEquals(final InputStream is1,
+	    final InputStream is2) {
+	if (is1 == is2) {
+	    return true;
 	}
+	if (is1 == null && is2 == null) {
+	    return true;
+	}
+	if (is1 == null || is2 == null) {
+	    return false;
+	}
+	try {
+	    int read1 = -1;
+	    int read2 = -1;
 
-	/**
-	 * Search through a given directory and return an ArrayList of any files/folders who's names match the given pattern.
-	 * 
-	 * @param patternString		The regular expression pattern to use in matching applicable file/folder names
-	 * @param parent			The folder to search for matches in.
-	 * @return					All files/folders matching the given pattern.
-	 */
-	private static ArrayList<File> matchFiles(String patternString, File parent){
-		Pattern pattern = Pattern.compile(patternString);
-		Matcher matcher;
-		ArrayList<File> files = new ArrayList <File>();
-		for (File file : parent.listFiles()){ 
-			matcher = pattern.matcher(file.getName());
-			if (matcher.matches()){
-				files.add(file);
-			}
+	    do {
+		int offset1 = 0;
+		while (offset1 < BUFFSIZE
+			&& (read1 = is1
+				.read(buff1, offset1, BUFFSIZE - offset1)) >= 0) {
+		    offset1 += read1;
 		}
-		return files;
 
+		int offset2 = 0;
+		while (offset2 < BUFFSIZE
+			&& (read2 = is2
+				.read(buff2, offset2, BUFFSIZE - offset2)) >= 0) {
+		    offset2 += read2;
+		}
+		if (offset1 != offset2) {
+		    return false;
+		}
+		if (offset1 != BUFFSIZE) {
+		    Arrays.fill(buff1, offset1, BUFFSIZE, (byte) 0);
+		    Arrays.fill(buff2, offset2, BUFFSIZE, (byte) 0);
+		}
+		if (!Arrays.equals(buff1, buff2)) {
+		    return false;
+		}
+	    } while (read1 >= 0 && read2 >= 0);
+	    if (read1 < 0 && read2 < 0) {
+		return true; // both at EOF
+	    }
+	    return false;
+
+	} catch (Exception ei) {
+	    return false;
 	}
-		
-	/**
-	 * Replace variable names with their values.
-	 * 
-	 * @param spp				The SimplePOMParser containing the required variables.
-	 * @param value				The String to be filtered.
-	 * @return					The new String with variable names replaced with values
-	 */
-	private static String variableReplace(SimplePOMParser spp, String value){
-		
-		value = value.replace("_ROOT_", "");
-		value = value.replace("_MAJOR_", Integer.toString(spp.getMajor()));
-		value = value.replace("_MINOR_", Integer.toString(spp.getMinor()));
-		value = value.replace("_PATCH_", Integer.toString(spp.getPatch()));
-		return value;
-		
+    }
+
+    public static boolean fileContentsEquals(final File file1, final File file2) {
+	InputStream is1 = null;
+	InputStream is2 = null;
+	if (file1.length() != file2.length()) {
+	    return false;
 	}
-	
-	/**
-	 * Validate the the required path exists in the project on the repository. If it doesn't then create it.
-	 * 
-	 * @param repository		The repository to be checked.
-	 * @param commitClient		The SVNCommitClient to be used to preform any commit actions.
-	 * @param svnURL			The URL of the project in the repository.
-	 * @param path				The path within the project to be checked/created.
-	 */
-	private static void ensurePath(SVNRepository repository, SVNCommitClient commitClient, String svnURL, String path){
-		String[] dirs = path.split("/");
-		String constructedPath = "";
-		
-		if (dirs.length > 0){
-			
-			for (int i = 0; i < dirs.length; i++){
-				try{
-					SVNNodeKind nodeKind = repository.checkPath(constructedPath + dirs[i], -1);
-					if (nodeKind == SVNNodeKind.NONE){
-						createDir(commitClient, svnURL + "/" +  constructedPath + dirs[i]);
-					}
-					constructedPath += dirs[i] + "/";
-					
-				}catch (SVNException svne) {
-					System.err.println("SVNForceImport Error: " + svne.getMessage());
-				}
-			}
+
+	try {
+	    is1 = new FileInputStream(file1);
+	    is2 = new FileInputStream(file2);
+
+	    return inputStreamEquals(is1, is2);
+
+	} catch (Exception ei) {
+	    return false;
+	} finally {
+	    try {
+		if (is1 != null) {
+		    is1.close();
 		}
+		if (is2 != null) {
+		    is2.close();
+		}
+	    } catch (Exception ei2) {
+	    }
 	}
+    }
 }
Index: src/main/resources/com/mtvi/plateng/subversion/SVNPublisher/global.jelly
===================================================================
--- src/main/resources/com/mtvi/plateng/subversion/SVNPublisher/global.jelly	(revision 39591)
+++ src/main/resources/com/mtvi/plateng/subversion/SVNPublisher/global.jelly	(working copy)
@@ -1,6 +1,7 @@
 <j:jelly xmlns:j="jelly:core" xmlns:st="jelly:stapler"
 	xmlns:d="jelly:define" xmlns:l="/lib/layout" xmlns:t="/lib/hudson"
 	xmlns:f="/lib/form">
+	<!--
 	<f:section title="Global SVN Publisher Settings">
 		<f:entry title="User" help="/plugin/svnpublisher/help-global-user.html">
 			<input class="setting-input" name="svnpublish.user" type="text"
@@ -10,5 +11,5 @@
 			<input class="setting-input" name="svnpublish.password"
 				type="password" value="${descriptor.password}" />
 		</f:entry>
-	</f:section>
+	</f:section>-->
 </j:jelly>
Index: src/main/resources/com/mtvi/plateng/subversion/SVNPublisher/config.jelly
===================================================================
--- src/main/resources/com/mtvi/plateng/subversion/SVNPublisher/config.jelly	(revision 39591)
+++ src/main/resources/com/mtvi/plateng/subversion/SVNPublisher/config.jelly	(working copy)
@@ -1,4 +1,13 @@
 <j:jelly xmlns:j="jelly:core" xmlns:st="jelly:stapler" xmlns:d="jelly:define" xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form">
+  	<f:entry title="User" help="/plugin/svnpublisher/help-global-user.html">
+		<input class="setting-input" name="svnpublish.user" type="text"
+			value="${instance.user}" />
+	</f:entry>
+	<f:entry title="Password" help="/plugin/svnpublisher/help-global-password.html">
+		<input class="setting-input" name="svnpublish.password"
+			type="password" value="${instance.password}" />
+	</f:entry>
+  
   <f:entry title="SVN URL:" help="/plugin/svnpublisher/help-svnUrl.html">
 	<input class="setting-input" name="svnpublish.svnUrl" type="text" value="${instance.svnUrl}" />
   </f:entry>
Index: pom.xml
===================================================================
--- pom.xml	(revision 39591)
+++ pom.xml	(working copy)
@@ -1,33 +1,58 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-    <parent>
-        <groupId>org.jvnet.hudson.plugins</groupId>
-        <artifactId>plugin</artifactId>
-        <version>1.319</version>
-        <relativePath>../pom.xml</relativePath>
-    </parent>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+	<modelVersion>4.0.0</modelVersion>
+	<parent>
+		<groupId>org.jenkins-ci.plugins</groupId>
+		<artifactId>plugin</artifactId>
+		<version>1.399</version>
+	</parent>
 
-    <groupId>com.mtvi.plateng.subversion</groupId>
-    <artifactId>svnpublisher</artifactId>
-    <packaging>hpi</packaging>
-    <version>0.2-SNAPSHOT</version>
-    <name>SVN Publisher plugin</name>
-    <description>
-        Plugin for Hudson that publishes to SVN.
+	<groupId>com.mtvi.plateng.subversion</groupId>
+	<artifactId>svnpublisher</artifactId>
+	<packaging>hpi</packaging>
+	<version>0.2-SNAPSHOT</version>
+	<name>SVN Publisher plugin</name>
+	<description>
+        Plugin for Jenkins that publishes to SVN.
     </description>
-    <url>http://wiki.hudson-ci.org/display/HUDSON/SVN+Publisher</url>
-    <developers>
-        <developer>
-            <id>brentsmith</id>
-            <name>Brent Smith</name>
-        </developer>
-    </developers>
+	<url>https://wiki.jenkins-ci.org/display/JENKINS/SVN+Publisher</url>
 
-    <dependencies>
-        <dependency>
-            <groupId>org.jvnet.hudson.plugins</groupId>
-            <artifactId>subversion</artifactId>
-            <version>[1.3,)</version>
-        </dependency>
-    </dependencies>
+	<scm>
+		<connection>scm:svn:https://svn.jenkins-ci.org/trunk/hudson/plugins/svnpublisher</connection>
+		<developerConnection>scm:svn:https://svn.jenkins-ci.org/trunk/hudson/plugins/svnpublisher</developerConnection>
+	</scm>
+
+	<developers>
+		<developer>
+			<id>brentsmith</id>
+			<name>Brent Smith</name>
+		</developer>
+	</developers>
+
+	<dependencies>
+		<dependency>
+			<groupId>org.jvnet.hudson.plugins</groupId>
+			<artifactId>subversion</artifactId>
+			<version>[1.3,)</version>
+		</dependency>
+	</dependencies>
+
+	<build>
+		<plugins>
+			<plugin>
+				<artifactId>maven-release-plugin</artifactId>
+				<configuration>
+					<goals>deploy</goals>
+				</configuration>
+			</plugin>
+		</plugins>
+	</build>
+ 
+	<distributionManagement>
+		<repository>
+			<id>maven.jenkins-ci.org</id>
+			<url>http://maven.jenkins-ci.org:8081/content/repositories/releases/</url>
+		</repository>
+	</distributionManagement>
+
 </project>
